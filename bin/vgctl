#!/usr/bin/env ruby

require File.expand_path(File.dirname(__FILE__) + "/../lib/vagrant/tools")
require 'getoptlong'


def main()
  # configure vgtools
  vgtools_cfg = Vagrant::Tools.config do |c|
    # defaults
    c.prefix = ENV["HOME"]
    c.verbose = false
    c.output = {machine: false, long: false, only_active: false}
    c.target = nil
    c.cmd = nil
    c.refresh_cache = false
    # parse regular commands with getopt
    begin
      opts = GetoptLong.new(
        ['--prefix', '-p', GetoptLong::REQUIRED_ARGUMENT],
        ['--verbose', '-v', GetoptLong::NO_ARGUMENT],
        ['--refresh-cache', '-x', GetoptLong::NO_ARGUMENT],
        ['--only-active', '-a', GetoptLong::NO_ARGUMENT],
        ['--help', '-h', GetoptLong::NO_ARGUMENT],
      )
      opts.each do |opt, arg|
        case opt
          when '--prefix'
            c.prefix = arg
            c.refresh_cache = true
          when '--verbose'
            c.verbose = true
          when '--refresh-cache'
            c.refresh_cache = true
          when '--only-active'
            c.output[:only_active] = true
          when '--help'
            puts <<-EOF
vgctl, version: #{Vagrant::Tools::VERSION}

usage: vgctl [-pvxhc] [target command]
  
  p : set lookup prefix (default $HOME)
  v : verbose output
  x : refresh cached results (.vagrant lookup)
  target : target a specific config (vagrantfile dir)
  command : run vagrant command relative to target

  h : show this help message

            EOF
          exit
        else
          puts "extra: " + opt + "|" + arg
        end
      end
    rescue GetoptLong::InvalidOption => e
      exit
    end

    # parse commands and targets (outside getopt)
    ARGV.each_with_index do |arg, i|
      case i
      when 0
        c.target = arg
      when 1
        c.cmd = ARGV[1..-1].join(" ")
        break
      end
    end
  end

  cfg = Vagrant::Tools.get_config 
  verify = vgtools_cfg.verify? do |errors|
    # if cfg.target.nil? || cfg.target == "
    errors[:target] = "target does not exist" if cfg.target.nil?
    errors[:cmd] = "invalid" if cfg.cmd.nil? || cfg.cmd == ""
    # errors[:]
  end
  unless verify
    puts vgtools_cfg.error_messages
    exit
  end

  # print verbose message
  if cfg.verbose
    puts "running `#{File.basename(__FILE__)}` in verbose mode (disable by removing -v [options])"
    puts "using options: "
    puts vgtools_cfg.to_s
  end
  
  # find config root by target name (project root name)
  root = Vagrant::Tools::Root.new
  config = root.find_by_project_root(cfg.target)
  if config.nil?
    puts "target config not found"
    exit
  else
    puts "executing: #{cfg.cmd}" if cfg.verbose
  end
  # execute command relative to config
  config.exec_vagrant_command(cfg.cmd)
end

# entry point
if File.basename(__FILE__) == File.basename($0)
  begin
    main()
  rescue Interrupt
    exit 0
  end
end
